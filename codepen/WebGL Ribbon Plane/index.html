<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Oswald:wght@200;300;400;500&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      html,
      body {
        margin: 0;
        font-family: "Oswald", sans-serif;
      }

      .webgl {
        position: fixed;
        left: 0;
        top: 0;
        outline: none;
      }
    </style>
  </head>
  <body>
    <canvas class="webgl"></canvas>

    <script src="CCapture.all.min.js"></script>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"
      integrity="sha512-VEBjfxWUOyzl0bAwh4gdLEaQyDYPvLrZql3pw1ifgb6fhEvZl9iDDehwHZ+dsMzA0Jfww8Xt7COSZuJ/slxc4Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@<version>/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "https://cdn.skypack.dev/three@0.133.1/build/three.module";
      import { OrbitControls } from "https://cdn.skypack.dev/three@0.133.1/examples/jsm/controls/OrbitControls";
      import { Curves } from "https://cdn.skypack.dev/three@0.133.1/examples/jsm/curves/CurveExtras.js";
      import ParametricGeometry from "https://cdn.skypack.dev/three@0.133.1/examples/jsm/geometries/ParametricGeometry.js";
      // import { HelixCurve } from "https://cdn.skypack.dev/three@0.133.1/examples/jsm/curves/CurveExtras.js";

      // Canvas
      const canvas = document.querySelector("canvas.webgl");

      // Scene
      const scene = new THREE.Scene();

      // Object
      const geometry = new THREE.PlaneGeometry(5, 3, 50, 25);
      const uniforms = {
        uAmplitude: {
          value: 1.0,
        },
        uTime: {
          value: 0,
        },
        uColor: {
          value: new THREE.Color(0xff0000),
        },
        uScreenWidth: {
          value: window.innerWidth,
        },
      };

      const material = new THREE.MeshBasicMaterial({
        color: 0xff00000,
        wireframe: true,
      });
      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms,
        wireframe: true,
        vertexShader: `
            uniform float uTime;
            uniform float uScreenWidth;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying float vNoise;

            // Simplex 2D noise
            vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

            float snoise(vec2 v){
              const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                      -0.577350269189626, 0.024390243902439);
              vec2 i  = floor(v + dot(v, C.yy) );
              vec2 x0 = v -   i + dot(i, C.xx);
              vec2 i1;
              i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz;
              x12.xy -= i1;
              i = mod(i, 289.0);
              vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
              + i.x + vec3(0.0, i1.x, 1.0 ));
              vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                dot(x12.zw,x12.zw)), 0.0);
              m = m*m ;
              m = m*m ;
              vec3 x = 2.0 * fract(p * C.www) - 1.0;
              vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5);
              vec3 a0 = x - ox;
              m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
              vec3 g;
              g.x  = a0.x  * x0.x  + h.x  * x0.y;
              g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
            }

            void main() {
              vUv = uv;
              vNormal = normal;

              float displacement = 0.0;

              vec4 modalPosition = modelMatrix * vec4( position, 1.0 );

              modalPosition.y += (modalPosition.x * 0.5);
              displacement = snoise(modalPosition.xy * .5) * .3;

              modalPosition.z += displacement;

              gl_Position = projectionMatrix * viewMatrix * modalPosition;
            }
              `,
        fragmentShader: `
            uniform float uTime;
            uniform vec3 uColor;
            uniform sampler2D uTexture;

            varying float vNoise;
            varying vec3 vNormal;
            varying vec2 vUv;

            float random( vec3 scale, float seed ){
              return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;
            }

            void main() {
              // texture
              vec4 color = texture2D(uTexture, vUv);


              // float r = 0.001 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );
              // vec2 tPos = vec2( 0, 1.3 * vNoise + r );
              // vec4 color = vec4(vUv.x,0.5,1.-vUv.x,.0);

              gl_FragColor = vec4( uColor.rgb, 1.0 );
            }
              `,
      });
      const mesh = new THREE.Mesh(geometry, shaderMaterial);
      scene.add(mesh);

      // Sizes
      const sizes = {
        width: window.innerWidth,
        height: window.innerHeight,
      };

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        sizes.width / sizes.height
      );
      camera.position.z = 4;
      scene.add(camera);

      // Controls
      const controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
      });
      renderer.setSize(sizes.width, sizes.height);
      renderer.render(scene, camera);

      // Events
      window.addEventListener("resize", () => {
        sizes.width = window.innerWidth;
        sizes.height = window.innerHeight;

        camera.aspect = sizes.width / sizes.height;
        camera.updateProjectionMatrix();

        renderer.setSize(sizes.width, sizes.height);
      });

      /**
       * Animate
       */
      const clock = new THREE.Clock();

      const tick = () => {
        const elapsedTime = clock.getElapsedTime();

        // Update controls
        controls.update();

        // Render
        renderer.render(scene, camera);

        // Call tick again on the next frame
        window.requestAnimationFrame(tick);
      };

      tick();
    </script>
  </body>
</html>
