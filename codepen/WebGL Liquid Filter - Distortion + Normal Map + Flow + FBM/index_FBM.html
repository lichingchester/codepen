<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <style>
      html,
      body {
        margin: 0;
        background-color: #222;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      .webgl {
        outline: none;
      }
    </style>
  </head>
  <body>
    <canvas class="webgl"></canvas>

    <script src="CCapture.all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@<version>/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "https://cdn.skypack.dev/three@0.133.1/build/three.module";
      import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js";

      // SVG Content
      const svgContent = `
<svg width="622" height="157" viewBox="0 0 622 157" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M621.04 2.26999H561.83L543.22 153.68H602.92L606.32 125.76H576.13L580.45 91.76H606.55L610.18 63.16H583.85L587.94 30.47H617.68L621.04 2.26999Z"
      fill="white"
    />
    <path d="M533.63 125.31H502.76L517.76 2.31H488.23L469.62 153.68H530.04L533.63 125.31Z" fill="white" />
    <path d="M465.34 2.26999H435.83L417.22 153.68H446.73L465.34 2.26999Z" fill="white" />
    <path
      d="M403.65 2.26999H364.15L341.23 91.71L337.6 2.26999H298.78L267.04 153.68H298.82L316.75 44.68C316.52 48.08 316.3 51.26 316.3 54.68C316.3 62.17 316.98 69.89 317.21 77.38C318.34 102.8 320.84 128.23 322.88 153.65H345.58L367.83 79.65C371.372 68.1583 374.25 56.4724 376.45 44.65L370.55 153.65H400.74L403.65 2.26999Z"
      fill="white"
    />
    <path
      d="M264.9 7.27C256.5 2.27 249.46 0 239.7 0C211.78 0 194.7 25.43 194.7 51.3C194.7 69.69 203.1 79 216.95 89.44C219.467 91.2026 221.89 93.0951 224.21 95.11C226.94 97.38 229.89 100.11 231.21 103.51C231.769 105.19 232 106.963 231.89 108.73C231.89 120.31 223.72 128.03 212.14 128.03C203.97 128.03 197.84 124.63 191.48 119.86L187.85 148.46C195.12 153.91 203.74 156.18 212.85 156.18C242.59 156.18 261.43 130.53 261.43 102.38C261.43 69.47 224.2 65.83 224.2 44.04C224.2 34.04 231.01 26.79 241 26.79C249.18 26.79 255.53 31.1 261.2 36.55L264.9 7.27Z"
      fill="white"
    />
    <path
      d="M76.5 155.68C118.75 155.68 153 121.43 153 79.18C153 36.9302 118.75 2.67999 76.5 2.67999C34.2502 2.67999 0 36.9302 0 79.18C0 121.43 34.2502 155.68 76.5 155.68Z"
      fill="white"
    />
</svg>
`;

      // Debug parameters
      const params = {
        // Distortion
        distortionIntensity: 0.052,
        distortionSpeed: 1,
        distortionScale: 8.0,
        noise1Weight: 0.5,
        noise2Weight: 0.3,
        noise3Weight: 0.2,
        noise2Scale: 2.0,
        noise3Scale: 4.0,
        noise2Speed: 0.7,
        noise3Speed: 0.5,

        // Animation
        animationEnabled: true,
        animationDuration: 3.8,
        animationDelay: 0.5,
        edgeWidth: 0.15,
        manualProgress: 0,

        // Effects
        chromaticAberration: 0.0011,
        edgeFog: 0.15,
        vignetteIntensity: 0.0,
        normalMapInfluence: 0.02,

        // Normal Map
        normalMapScale: 4.0,
        normalMapOffset: 0.001,

        // Flow
        flowSpeed: 0.1,
        flowStrength: 0.2,

        // FBM
        fbmOctaves: 5,
        fbmSpeed: 0.5,
        fbmAmplitude: 0.5,
        fbmFrequency: 1.0,
        fbmLacunarity: 2.0,
        fbmGain: 0.5,
      };

      // Shaders
      const vertexShader = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

      const fragmentShader = `
uniform sampler2D uTexture;
uniform float uTime;
uniform vec2 uMouse;
uniform float uProgress;

// Uniforms for tweakable parameters
uniform float uDistortionIntensity;
uniform float uDistortionSpeed;
uniform float uDistortionScale;
uniform float uNoise1Weight;
uniform float uNoise2Weight;
uniform float uNoise3Weight;
uniform float uNoise2Scale;
uniform float uNoise3Scale;
uniform float uNoise2Speed;
uniform float uNoise3Speed;
uniform float uEdgeWidth;
uniform float uChromaticAberration;
uniform float uEdgeFog;
uniform float uVignetteIntensity;
uniform float uNormalMapInfluence;
uniform float uNormalMapScale;
uniform float uNormalMapOffset;
uniform float uFlowSpeed;
uniform float uFlowStrength;
uniform float uFbmSpeed;
uniform float uFbmAmplitude;
uniform float uFbmFrequency;
uniform float uFbmLacunarity;
uniform float uFbmGain;

varying vec2 vUv;

// ========== GRADIENT NOISE ==========
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

float gradientNoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187,
                      0.366025403784439,
                     -0.577350269189626,
                      0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289_2(i);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Fractal Brownian Motion - Visualized with octave layers
float fbm(vec2 p, float time, out float octave1, out float octave2, out float octave3, out float octave4, out float octave5) {
  float value = 0.0;
  float amplitude = uFbmAmplitude;
  float frequency = uFbmFrequency;
  
  // Octave 1: Broad features
  octave1 = amplitude * gradientNoise(p * frequency + time * uFbmSpeed);
  value += octave1;
  frequency *= uFbmLacunarity;
  amplitude *= uFbmGain;
  
  // Octave 2: Medium details
  octave2 = amplitude * gradientNoise(p * frequency + time * uFbmSpeed);
  value += octave2;
  frequency *= uFbmLacunarity;
  amplitude *= uFbmGain;
  
  // Octave 3: Fine details
  octave3 = amplitude * gradientNoise(p * frequency + time * uFbmSpeed);
  value += octave3;
  frequency *= uFbmLacunarity;
  amplitude *= uFbmGain;
  
  // Octave 4: Tiny bumps
  octave4 = amplitude * gradientNoise(p * frequency + time * uFbmSpeed);
  value += octave4;
  frequency *= uFbmLacunarity;
  amplitude *= uFbmGain;
  
  // Octave 5: Micro texture
  octave5 = amplitude * gradientNoise(p * frequency + time * uFbmSpeed);
  value += octave5;
  
  return value;
}

// Simple FBM for normal map and distortion (no visualization)
float fbmSimple(vec2 p, float time) {
  float value = 0.0;
  float amplitude = uFbmAmplitude;
  float frequency = uFbmFrequency;
  
  for(int i = 0; i < 5; i++) {
    value += amplitude * gradientNoise(p * frequency + time * uFbmSpeed);
    frequency *= uFbmLacunarity;
    amplitude *= uFbmGain;
  }
  return value;
}

// ========== NORMAL MAP GENERATION ==========
vec3 generateNormalMap(vec2 uv, float time) {
  float offset = uNormalMapOffset;
  
  float center = fbmSimple(uv, time);
  float right = fbmSimple(uv + vec2(offset, 0.0), time);
  float top = fbmSimple(uv + vec2(0.0, offset), time);
  
  float dx = (right - center) / offset;
  float dy = (top - center) / offset;
  
  vec3 normal = normalize(vec3(-dx, -dy, 1.0));
  
  return normal * 0.5 + 0.5;
}

// ========== FROSTED GLASS DISTORTION ==========
vec2 getFrostedGlassDistortion(vec2 uv, float time, float intensity) {
  float noise1 = fbmSimple(uv * uDistortionScale, time * uDistortionSpeed);
  float noise2 = fbmSimple(uv * uDistortionScale * uNoise2Scale, time * uDistortionSpeed * uNoise2Speed);
  float noise3 = fbmSimple(uv * uDistortionScale * uNoise3Scale, time * uDistortionSpeed * uNoise3Speed);
  
  vec2 distortion = vec2(noise1 * uNoise1Weight + noise2 * uNoise2Weight + noise3 * uNoise3Weight);
  
  float flowAngle = time * uFlowSpeed + noise1;
  distortion += vec2(cos(flowAngle), sin(flowAngle)) * uFlowStrength;
  
  return distortion * intensity;
}

// ========== POST-PROCESSING EFFECTS ==========
vec3 chromaticAberration(sampler2D tex, vec2 uv, vec2 direction, float strength) {
  vec2 offset = direction * strength;
  float r = texture2D(tex, uv + offset).r;
  float g = texture2D(tex, uv).g;
  float b = texture2D(tex, uv - offset).b;
  return vec3(r, g, b);
}

float vignette(vec2 uv, float intensity) {
  vec2 centered = uv - 0.5;
  float dist = length(centered);
  return 1.0 - smoothstep(0.3, 0.8, dist) * intensity;
}

// ========== MAIN ==========
void main() {
  vec2 uv = vUv;
  
  // Divide screen into 2 rows: top row (0.0-0.6) for sections 1-5, bottom row (0.6-1.0) for section 6
  // Note: UV coordinates go from bottom to top, so we need to flip the logic
  float rowSplit = 0.4; // Bottom 40% for section 6
  int section = -1;
  vec3 color = vec3(0.0);
  
  if (uv.y > rowSplit) {
    // Top row: 5 sections (sections 1-5)
    float sectionWidth = 1.0 / 5.0;
    section = int(floor(uv.x / sectionWidth));
    
    // Create visualization UV - map to 0-1 range for top row
    vec2 vizUv = vec2(uv.x, (uv.y - rowSplit) / (1.0 - rowSplit));
    
    // Calculate FBM with individual octaves
    float o1, o2, o3, o4, o5;
    float fbmValue = fbm(vizUv * 4.0, uTime, o1, o2, o3, o4, o5);
    
    if (section == 0) {
      // Section 1: Octave 1 only (broad features)
      float val = o1 * 0.5 + 0.5;
      color = vec3(val);
    } else if (section == 1) {
      // Section 2: Octave 1 + 2 (medium details)
      float val = (o1 + o2) * 0.5 + 0.5;
      color = vec3(val);
    } else if (section == 2) {
      // Section 3: Octave 1 + 2 + 3 (fine details)
      float val = (o1 + o2 + o3) * 0.5 + 0.5;
      color = vec3(val);
    } else if (section == 3) {
      // Section 4: Octave 1 + 2 + 3 + 4 (tiny bumps)
      float val = (o1 + o2 + o3 + o4) * 0.5 + 0.5;
      color = vec3(val);
    } else if (section == 4) {
      // Section 5: All 5 octaves (micro texture)
      float val = fbmValue * 0.5 + 0.5;
      color = vec3(val);
    }
    
    // Add vertical section dividers for top row
    float dividerWidth = 0.002;
    float dividerDist = mod(uv.x, sectionWidth);
    if (dividerDist < dividerWidth || dividerDist > sectionWidth - dividerWidth) {
      color = mix(color, vec3(0.5), 0.3);
    }
  } else {
    // Bottom row: Section 6 - Full width with logo
    section = 5;
    
    // Map bottom row UV to 0-1 range
    vec2 bottomUv = vec2(uv.x, uv.y / rowSplit);
    
    // Account for logo aspect ratio (622/157 ≈ 3.96)
    float logoAspect = 622.0 / 257.0;
    // Container aspect: full width (1.0) / bottom row height (rowSplit)
    float containerAspect = 1.0 / rowSplit;
    
    vec2 texUv = bottomUv - 0.5;
    // Scale to fit logo in container while maintaining aspect ratio
    if (containerAspect > logoAspect) {
      // Container is wider than logo - fit to height
      texUv.x *= containerAspect / logoAspect;
    } else {
      // Container is taller than logo - fit to width
      texUv.y *= logoAspect / containerAspect;
    }
    texUv = texUv + 0.5;
    texUv = texUv * 1.5 - 0.25; // Zoom in a bit and center
    
    float maskStart = uProgress - uEdgeWidth;
    float maskEnd = uProgress;
    float progressMask = smoothstep(maskStart, maskEnd, texUv.x);
    
    vec3 normalMap = generateNormalMap(texUv * uNormalMapScale, uTime);
    
    float distortionIntensity = uDistortionIntensity * progressMask;
    vec2 glassDistortion = getFrostedGlassDistortion(texUv, uTime, distortionIntensity);
    
    glassDistortion += (normalMap.xy - 0.5) * uNormalMapInfluence * progressMask;
    
    vec2 distortedUv = texUv + glassDistortion;
    
    if (distortedUv.x < 0.0 || distortedUv.x > 1.0 || distortedUv.y < 0.0 || distortedUv.y > 1.0) {
      color = vec3(0.0);
    } else {
      vec2 aberrationDir = (normalMap.xy - 0.5) * 2.0;
      float aberrationStrength = uChromaticAberration * progressMask;
      color = chromaticAberration(uTexture, distortedUv, aberrationDir, aberrationStrength);
      
      float edgeFog = smoothstep(maskStart + 0.05, maskEnd - 0.05, texUv.x);
      edgeFog = 1.0 - edgeFog;
      color = mix(color, vec3(1.0), edgeFog * uEdgeFog * progressMask);
      
      float vig = vignette(distortedUv, uVignetteIntensity * progressMask);
      color *= vig;
    }
  }
  
  // Add horizontal divider between rows
  float rowDividerHeight = 0.003;
  if (abs(uv.y - rowSplit) < rowDividerHeight) {
    color = mix(color, vec3(0.5), 0.3);
  }
  
  gl_FragColor = vec4(color, 1.0);
}
`;

      // Canvas
      const canvas = document.querySelector("canvas.webgl");

      // Scene
      const scene = new THREE.Scene();

      // Sizes
      const width = 622 * 2.5;
      const height = 357 * 2.5;
      // const width = 622 * 2.5;
      // const height = 157 * 2.5;
      const padding = 0;
      const canvasWidth = width + padding * 2;
      const canvasHeight = height + padding * 2;
      const aspectRatio = canvasWidth / canvasHeight;

      // Camera - Orthographic
      const frustumSize = 1;
      const camera = new THREE.OrthographicCamera(
        (frustumSize * aspectRatio) / -2,
        (frustumSize * aspectRatio) / 2,
        frustumSize / 2,
        frustumSize / -2,
        0.1,
        1000
      );
      camera.position.z = 1;
      scene.add(camera);

      // Helper grid
      // const helper = new THREE.GridHelper(160, 10, 0x8d8d8d, 0xc1c1c1);
      // helper.rotation.x = Math.PI / 2;
      // scene.add(helper);

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        alpha: true,
        antialias: true,
      });
      renderer.setSize(canvasWidth, canvasHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Load SVG Texture
      let material;
      let progressAnimation;

      const img = new Image();
      img.width = width * 2;
      img.height = height * 2;

      const svgBlob = new Blob([svgContent], { type: "image/svg+xml" });
      const url = URL.createObjectURL(svgBlob);

      img.onload = () => {
        const canvasEl = document.createElement("canvas");
        canvasEl.width = width * 2;
        canvasEl.height = height * 2;
        const ctx = canvasEl.getContext("2d");
        if (ctx) {
          ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
        }

        const texture = new THREE.CanvasTexture(canvasEl);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const svgAspectRatio = width / height;
        const geometry = new THREE.PlaneGeometry(svgAspectRatio, 1, 32, 32);

        material = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader,
          uniforms: {
            uTime: { value: 0 },
            uTexture: { value: texture },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uProgress: { value: 0 },
            // Tweakable uniforms
            uDistortionIntensity: { value: params.distortionIntensity },
            uDistortionSpeed: { value: params.distortionSpeed },
            uDistortionScale: { value: params.distortionScale },
            uNoise1Weight: { value: params.noise1Weight },
            uNoise2Weight: { value: params.noise2Weight },
            uNoise3Weight: { value: params.noise3Weight },
            uNoise2Scale: { value: params.noise2Scale },
            uNoise3Scale: { value: params.noise3Scale },
            uNoise2Speed: { value: params.noise2Speed },
            uNoise3Speed: { value: params.noise3Speed },
            uEdgeWidth: { value: params.edgeWidth },
            uChromaticAberration: { value: params.chromaticAberration },
            uEdgeFog: { value: params.edgeFog },
            uVignetteIntensity: { value: params.vignetteIntensity },
            uNormalMapInfluence: { value: params.normalMapInfluence },
            uNormalMapScale: { value: params.normalMapScale },
            uNormalMapOffset: { value: params.normalMapOffset },
            uFlowSpeed: { value: params.flowSpeed },
            uFlowStrength: { value: params.flowStrength },
            uFbmSpeed: { value: params.fbmSpeed },
            uFbmAmplitude: { value: params.fbmAmplitude },
            uFbmFrequency: { value: params.fbmFrequency },
            uFbmLacunarity: { value: params.fbmLacunarity },
            uFbmGain: { value: params.fbmGain },
          },
          transparent: true,
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Animate progress using GSAP
        // progressAnimation = gsap.to(material.uniforms.uProgress, {
        //   value: 1.2,
        //   duration: params.animationDuration,
        //   ease: "power2.inOut",
        //   repeat: -1,
        //   yoyo: true,
        //   repeatDelay: params.animationDelay,
        // });

        URL.revokeObjectURL(url);
      };

      img.src = url;

      // Events
      window.addEventListener("resize", () => {
        renderer.setSize(canvasWidth, canvasHeight);
      });

      // Animation Loop
      const clock = new THREE.Clock();

      const tick = () => {
        const elapsedTime = clock.getElapsedTime();

        if (material) {
          material.uniforms.uTime.value = elapsedTime;
        }

        renderer.render(scene, camera);

        window.requestAnimationFrame(tick);
      };

      tick();

      // Debug UI with Tweakpane
      const pane = new Pane({
        title: "FBM Visualization Controls",
        expanded: true,
      });

      // Info text
      pane.addBlade({
        view: "text",
        label: "Sections",
        value: "1→5: Octave layers | 6: Final effect",
        parse: (v) => String(v),
      });

      // FBM Parameters - Core Controls
      const fbmFolder = pane.addFolder({
        title: "FBM Parameters",
        expanded: true,
      });

      fbmFolder
        .addBinding(params, "fbmSpeed", {
          min: 0,
          max: 2,
          step: 0.01,
          label: "Animation Speed",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uFbmSpeed.value = ev.value;
        });

      fbmFolder
        .addBinding(params, "fbmAmplitude", {
          min: 0,
          max: 2,
          step: 0.01,
          label: "Amplitude (Start)",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uFbmAmplitude.value = ev.value;
        });

      fbmFolder
        .addBinding(params, "fbmFrequency", {
          min: 0.1,
          max: 5,
          step: 0.1,
          label: "Frequency (Start)",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uFbmFrequency.value = ev.value;
        });

      pane.addBlade({ view: "separator" });

      fbmFolder
        .addBinding(params, "fbmLacunarity", {
          min: 1,
          max: 4,
          step: 0.1,
          label: "Lacunarity",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uFbmLacunarity.value = ev.value;
        });

      fbmFolder.addBlade({
        view: "text",
        label: "Info",
        value: "Frequency multiplier per octave",
        parse: (v) => String(v),
      });

      fbmFolder
        .addBinding(params, "fbmGain", {
          min: 0,
          max: 1,
          step: 0.01,
          label: "Gain",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uFbmGain.value = ev.value;
        });

      fbmFolder.addBlade({
        view: "text",
        label: "Info",
        value: "Amplitude multiplier per octave",
        parse: (v) => String(v),
      });

      // Section 6 Effect Controls
      const section6Folder = pane.addFolder({
        title: "Section 6 - Final Effect",
        expanded: false,
      });

      section6Folder
        .addBinding(params, "distortionIntensity", {
          min: 0,
          max: 0.3,
          step: 0.001,
          label: "Distortion",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uDistortionIntensity.value = ev.value;
        });

      section6Folder
        .addBinding(params, "chromaticAberration", {
          min: 0,
          max: 0.02,
          step: 0.0001,
          label: "Chromatic AB",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uChromaticAberration.value = ev.value;
        });

      section6Folder
        .addBinding(params, "edgeFog", {
          min: 0,
          max: 0.5,
          step: 0.01,
          label: "Edge Fog",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uEdgeFog.value = ev.value;
        });

      // Export button
      pane.addBlade({ view: "separator" });
      pane.addButton({ title: "Export Config" }).on("click", () => {
        const config = {
          distortionIntensity: params.distortionIntensity,
          distortionSpeed: params.distortionSpeed,
          distortionScale: params.distortionScale,
          noise1Weight: params.noise1Weight,
          noise2Weight: params.noise2Weight,
          noise3Weight: params.noise3Weight,
          noise2Scale: params.noise2Scale,
          noise3Scale: params.noise3Scale,
          noise2Speed: params.noise2Speed,
          noise3Speed: params.noise3Speed,
          animationDuration: params.animationDuration,
          animationDelay: params.animationDelay,
          edgeWidth: params.edgeWidth,
          chromaticAberration: params.chromaticAberration,
          edgeFog: params.edgeFog,
          vignetteIntensity: params.vignetteIntensity,
          normalMapInfluence: params.normalMapInfluence,
          normalMapScale: params.normalMapScale,
          normalMapOffset: params.normalMapOffset,
          flowSpeed: params.flowSpeed,
          flowStrength: params.flowStrength,
          fbmSpeed: params.fbmSpeed,
          fbmAmplitude: params.fbmAmplitude,
          fbmFrequency: params.fbmFrequency,
          fbmLacunarity: params.fbmLacunarity,
          fbmGain: params.fbmGain,
        };

        const configJson = JSON.stringify(config, null, 2);

        const blob = new Blob([configJson], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `liquid-logo-config-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log("Config exported as file!");
      });
    </script>
  </body>
</html>
