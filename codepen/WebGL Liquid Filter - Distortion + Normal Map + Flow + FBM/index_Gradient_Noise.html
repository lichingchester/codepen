<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <style>
      html,
      body {
        margin: 0;
        background-color: #222;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      .webgl {
        outline: none;
      }
    </style>
  </head>
  <body>
    <canvas class="webgl"></canvas>

    <script src="CCapture.all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@<version>/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "https://cdn.skypack.dev/three@0.133.1/build/three.module";
      import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js";

      // SVG Content
      const svgContent = `
<svg width="622" height="157" viewBox="0 0 622 157" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      d="M621.04 2.26999H561.83L543.22 153.68H602.92L606.32 125.76H576.13L580.45 91.76H606.55L610.18 63.16H583.85L587.94 30.47H617.68L621.04 2.26999Z"
      fill="white"
    />
    <path d="M533.63 125.31H502.76L517.76 2.31H488.23L469.62 153.68H530.04L533.63 125.31Z" fill="white" />
    <path d="M465.34 2.26999H435.83L417.22 153.68H446.73L465.34 2.26999Z" fill="white" />
    <path
      d="M403.65 2.26999H364.15L341.23 91.71L337.6 2.26999H298.78L267.04 153.68H298.82L316.75 44.68C316.52 48.08 316.3 51.26 316.3 54.68C316.3 62.17 316.98 69.89 317.21 77.38C318.34 102.8 320.84 128.23 322.88 153.65H345.58L367.83 79.65C371.372 68.1583 374.25 56.4724 376.45 44.65L370.55 153.65H400.74L403.65 2.26999Z"
      fill="white"
    />
    <path
      d="M264.9 7.27C256.5 2.27 249.46 0 239.7 0C211.78 0 194.7 25.43 194.7 51.3C194.7 69.69 203.1 79 216.95 89.44C219.467 91.2026 221.89 93.0951 224.21 95.11C226.94 97.38 229.89 100.11 231.21 103.51C231.769 105.19 232 106.963 231.89 108.73C231.89 120.31 223.72 128.03 212.14 128.03C203.97 128.03 197.84 124.63 191.48 119.86L187.85 148.46C195.12 153.91 203.74 156.18 212.85 156.18C242.59 156.18 261.43 130.53 261.43 102.38C261.43 69.47 224.2 65.83 224.2 44.04C224.2 34.04 231.01 26.79 241 26.79C249.18 26.79 255.53 31.1 261.2 36.55L264.9 7.27Z"
      fill="white"
    />
    <path
      d="M76.5 155.68C118.75 155.68 153 121.43 153 79.18C153 36.9302 118.75 2.67999 76.5 2.67999C34.2502 2.67999 0 36.9302 0 79.18C0 121.43 34.2502 155.68 76.5 155.68Z"
      fill="white"
    />
</svg>
`;

      // Debug parameters
      const params = {
        // Distortion
        distortionIntensity: 0.052,
        distortionSpeed: 1,
        distortionScale: 8.0,
        noise1Weight: 0.5,
        noise2Weight: 0.3,
        noise3Weight: 0.2,
        noise2Scale: 2.0,
        noise3Scale: 4.0,
        noise2Speed: 0.7,
        noise3Speed: 0.5,

        // Animation
        animationEnabled: true,
        animationDuration: 3.8,
        animationDelay: 0.5,
        edgeWidth: 0.15,
        manualProgress: 0,

        // Effects
        chromaticAberration: 0.0011,
        edgeFog: 0.15,
        vignetteIntensity: 0.0,
        normalMapInfluence: 0.02,

        // Normal Map
        normalMapScale: 4.0,
        normalMapOffset: 0.001,

        // Flow
        flowSpeed: 0.1,
        flowStrength: 0.2,

        // FBM
        fbmOctaves: 5,
        fbmSpeed: 0.5,
        fbmAmplitude: 0.5,
        fbmFrequency: 1.0,
        fbmLacunarity: 2.0,
        fbmGain: 0.5,
      };

      // Shaders
      const vertexShader = `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

      const fragmentShader = `
uniform float uTime;
uniform float uDistortionScale;

varying vec2 vUv;

// ========== GRADIENT NOISE ==========
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

float gradientNoise(vec2 v) {
  const vec4 C = vec4(0.211324865405187,
                      0.366025403784439,
                     -0.577350269189626,
                      0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289_2(i);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// ========== MAIN ==========
void main() {
  vec2 uv = vUv;
  
  // Generate gradient noise pattern
  float noise = gradientNoise(uv * uDistortionScale + uTime * 0.1);
  
  // Normalize noise to 0-1 range for visualization
  noise = noise * 0.5 + 0.5;
  
  // Output as grayscale
  vec3 color = vec3(noise);
  
  gl_FragColor = vec4(color, 1.0);
}
`;

      // Canvas
      const canvas = document.querySelector("canvas.webgl");

      // Scene
      const scene = new THREE.Scene();

      // Sizes
      const width = 622 * 2.5;
      const height = 157 * 2.5;
      const padding = 0;
      const canvasWidth = width + padding * 2;
      const canvasHeight = height + padding * 2;
      const aspectRatio = canvasWidth / canvasHeight;

      // Camera - Orthographic
      const frustumSize = 1;
      const camera = new THREE.OrthographicCamera(
        (frustumSize * aspectRatio) / -2,
        (frustumSize * aspectRatio) / 2,
        frustumSize / 2,
        frustumSize / -2,
        0.1,
        1000
      );
      camera.position.z = 1;
      scene.add(camera);

      // Helper grid
      // const helper = new THREE.GridHelper(160, 10, 0x8d8d8d, 0xc1c1c1);
      // helper.rotation.x = Math.PI / 2;
      // scene.add(helper);

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        alpha: true,
        antialias: true,
      });
      renderer.setSize(canvasWidth, canvasHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Load SVG Texture
      let material;
      let progressAnimation;

      const img = new Image();
      img.width = width * 2;
      img.height = height * 2;

      const svgBlob = new Blob([svgContent], { type: "image/svg+xml" });
      const url = URL.createObjectURL(svgBlob);

      img.onload = () => {
        const canvasEl = document.createElement("canvas");
        canvasEl.width = width * 2;
        canvasEl.height = height * 2;
        const ctx = canvasEl.getContext("2d");
        if (ctx) {
          ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
        }

        const texture = new THREE.CanvasTexture(canvasEl);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const svgAspectRatio = width / height;
        const geometry = new THREE.PlaneGeometry(svgAspectRatio, 1, 32, 32);

        material = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader,
          uniforms: {
            uTime: { value: 0 },
            uTexture: { value: texture },
            uMouse: { value: new THREE.Vector2(0, 0) },
            uProgress: { value: 0 },
            // Tweakable uniforms
            uDistortionIntensity: { value: params.distortionIntensity },
            uDistortionSpeed: { value: params.distortionSpeed },
            uDistortionScale: { value: params.distortionScale },
            uNoise1Weight: { value: params.noise1Weight },
            uNoise2Weight: { value: params.noise2Weight },
            uNoise3Weight: { value: params.noise3Weight },
            uNoise2Scale: { value: params.noise2Scale },
            uNoise3Scale: { value: params.noise3Scale },
            uNoise2Speed: { value: params.noise2Speed },
            uNoise3Speed: { value: params.noise3Speed },
            uEdgeWidth: { value: params.edgeWidth },
            uChromaticAberration: { value: params.chromaticAberration },
            uEdgeFog: { value: params.edgeFog },
            uVignetteIntensity: { value: params.vignetteIntensity },
            uNormalMapInfluence: { value: params.normalMapInfluence },
            uNormalMapScale: { value: params.normalMapScale },
            uNormalMapOffset: { value: params.normalMapOffset },
            uFlowSpeed: { value: params.flowSpeed },
            uFlowStrength: { value: params.flowStrength },
            uFbmSpeed: { value: params.fbmSpeed },
            uFbmAmplitude: { value: params.fbmAmplitude },
            uFbmFrequency: { value: params.fbmFrequency },
            uFbmLacunarity: { value: params.fbmLacunarity },
            uFbmGain: { value: params.fbmGain },
          },
          transparent: true,
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Animate progress using GSAP
        progressAnimation = gsap.to(material.uniforms.uProgress, {
          value: 1.2,
          duration: params.animationDuration,
          ease: "power2.inOut",
          repeat: -1,
          yoyo: true,
          repeatDelay: params.animationDelay,
        });

        URL.revokeObjectURL(url);
      };

      img.src = url;

      // Events
      window.addEventListener("resize", () => {
        renderer.setSize(canvasWidth, canvasHeight);
      });

      // Animation Loop
      const clock = new THREE.Clock();

      const tick = () => {
        const elapsedTime = clock.getElapsedTime();

        if (material) {
          material.uniforms.uTime.value = elapsedTime;
        }

        renderer.render(scene, camera);

        window.requestAnimationFrame(tick);
      };

      tick();

      // Debug UI with Tweakpane
      const pane = new Pane({
        title: "Gradient Noise Controls",
        expanded: true,
      });

      // Info text
      pane.addBlade({
        view: "text",
        label: "Description",
        value: "Simple gradient noise visualization",
        parse: (v) => String(v),
      });

      pane.addBlade({ view: "separator" });

      // Noise Parameters
      pane
        .addBinding(params, "distortionScale", {
          min: 1,
          max: 32,
          step: 0.1,
          label: "Noise Scale",
        })
        .on("change", (ev) => {
          if (material) material.uniforms.uDistortionScale.value = ev.value;
        });

      pane.addBlade({
        view: "text",
        label: "Info",
        value: "Controls the frequency/detail of the noise pattern",
        parse: (v) => String(v),
      });
    </script>
  </body>
</html>
